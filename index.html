<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neon Flipper - Dynamic</title>
    <style>
        body { margin: 0; background-color: #111; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: sans-serif; color: #eee; text-align: center; }
        canvas { background-color: #1a1a1a; display: block; touch-action: none; border: 1px solid #333; }
        #container { display: flex; flex-direction: column; align-items: center; }
    </style>
</head>
<body>
<div id="container">
    <h3 id="score">Score: 0</h3>
    <canvas id="gameCanvas"></canvas>
</div>

<script>
    // === GRUNDEINSTELLUNGEN ===
    const canvas = document.getElementById('gameCanvas');
    const scoreElement = document.getElementById('score');
    const ctx = canvas.getContext('2d');

    canvas.width = Math.min(window.innerWidth * 0.9, 400);
    canvas.height = Math.min(window.innerHeight * 0.8, 700);

    // === SPIELOBJEKTE ===
    const paddle = {
        width: 100, height: 15, x: canvas.width / 2, y: canvas.height - 50,
        angle: 0, color: 'cyan', hitColor: 'red', isHit: false, hitTimeout: null
    };

    const ball = {
        x: canvas.width / 2, y: 50, radius: 8,
        vx: (Math.random() - 0.5) * 4, vy: 4, color: 'lime'
    };

    // GEÄNDERT: Jedes Hindernis bekommt eine eigene Geschwindigkeit (vx)
    const obstacles = [
        { x: canvas.width / 2 - 50, y: 200, width: 100, height: 20, vx: 1.5 },
        { x: 50, y: 350, width: 80, height: 20, vx: -1 },
        { x: canvas.width - 130, y: 350, width: 80, height: 20, vx: 1 }
    ];

    // === SPIELZUSTAND ===
    let score = 0;
    let gameOver = false;
    let lastTime = 0;

    const input = {
        isDragging: false, isInteractingMulti: false, startDragX: 0, startPaddleX: 0,
        startTouchAngle: 0, startPaddleAngle: 0
    };

    // === HELFERFUNKTIONEN (unverändert) ===
    function getTouchPositions(e) {
        const rect = canvas.getBoundingClientRect();
        if (e.touches) {
            return Array.from(e.touches).map(touch => ({
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            }));
        } else {
            return [{ x: e.clientX - rect.left, y: e.clientY - rect.top }];
        }
    }
    function getAngle(p1, p2) { return Math.atan2(p2.y - p1.y, p2.x - p1.x); }

    // === EVENT HANDLER (unverändert) ===
    function handleStart(e) {
        if (gameOver) return; e.preventDefault();
        const points = getTouchPositions(e);
        if (points.length === 1) {
            input.isDragging = true; input.startDragX = points[0].x; input.startPaddleX = paddle.x;
        } else if (points.length >= 2) {
            input.isInteractingMulti = true; input.startTouchAngle = getAngle(points[0], points[1]); input.startPaddleAngle = paddle.angle;
        }
    }
    function handleMove(e) {
        if (gameOver) return; e.preventDefault();
        const points = getTouchPositions(e);
        if (input.isDragging && points.length === 1) {
            const dx = points[0].x - input.startDragX; paddle.x = input.startPaddleX + dx;
        } else if (input.isInteractingMulti && points.length >= 2) {
            const currentAngle = getAngle(points[0], points[1]);
            paddle.angle = input.startPaddleAngle + (currentAngle - input.startTouchAngle);
        }
    }
    function handleEnd(e) { input.isDragging = false; input.isInteractingMulti = false; }

    canvas.addEventListener('touchstart', handleStart); canvas.addEventListener('touchmove', handleMove);
    canvas.addEventListener('touchend', handleEnd); canvas.addEventListener('touchcancel', handleEnd);
    canvas.addEventListener('mousedown', handleStart); canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', handleEnd); canvas.addEventListener('mouseleave', handleEnd);

    // === PHYSIK & KOLLISION ===
    function update(deltaTime) {
        if (gameOver) return;

        score += deltaTime;
        scoreElement.textContent = `Score: ${Math.floor(score)}`;

        // NEU: Logik, um die Hindernisse zu bewegen
        obstacles.forEach(obs => {
            // Position aktualisieren
            obs.x += obs.vx;

            // An den Wänden abprallen lassen
            if (obs.x < 0 || obs.x + obs.width > canvas.width) {
                obs.vx *= -1; // Richtung umkehren
            }
        });

        ball.x += ball.vx;
        ball.y += ball.vy;

        if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) ball.vx *= -1;
        if (ball.y - ball.radius < 0) ball.vy *= -1;

        if (ball.y - ball.radius > canvas.height) {
            gameOver = true; scoreElement.textContent = `Game Over! Score: ${Math.floor(score)}`;
        }

        // Hindernis-Kollision (Logik bleibt gleich, funktioniert nun mit bewegten Hindernissen)
        obstacles.forEach(obs => {
            if (ball.x > obs.x && ball.x < obs.x + obs.width &&
                ball.y + ball.radius > obs.y && ball.y - ball.radius < obs.y + obs.height) {
                ball.vy *= -1;
                ball.y += ball.vy; // Verhindert, dass der Ball im Hindernis stecken bleibt
            }
        });

        // Flipper-Brett-Kollision (unverändert)
        const dx = ball.x - paddle.x; const dy = ball.y - paddle.y;
        const rotatedX = dx * Math.cos(-paddle.angle) - dy * Math.sin(-paddle.angle);
        const rotatedY = dx * Math.sin(-paddle.angle) + dy * Math.cos(-paddle.angle);
        if (rotatedX > -paddle.width / 2 - ball.radius && rotatedX < paddle.width / 2 + ball.radius &&
            rotatedY > -paddle.height / 2 - ball.radius && rotatedY < paddle.height / 2 + ball.radius && ball.vy > 0) {
            paddle.isHit = true;
            if(paddle.hitTimeout) clearTimeout(paddle.hitTimeout);
            paddle.hitTimeout = setTimeout(() => { paddle.isHit = false; }, 150);
            const bounceAngle = paddle.angle - Math.PI / 2;
            const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            ball.vx = Math.cos(bounceAngle) * speed; ball.vy = Math.sin(bounceAngle) * speed;
        }
    }

    // === ZEICHENFUNKTIONEN (unverändert) ===
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#555';
        obstacles.forEach(obs => ctx.fillRect(obs.x, obs.y, obs.width, obs.height));
        ctx.fillStyle = ball.color;
        ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2); ctx.fill();
        ctx.save();
        ctx.translate(paddle.x, paddle.y); ctx.rotate(paddle.angle);
        ctx.fillStyle = paddle.isHit ? paddle.hitColor : paddle.color;
        ctx.fillRect(-paddle.width / 2, -paddle.height / 2, paddle.width, paddle.height);
        ctx.restore();
    }

    // === SPIEL-SCHLEIFE (unverändert) ===
    function gameLoop(timestamp) {
        const deltaTime = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        update(deltaTime || 0);
        draw();
        if(!gameOver) { requestAnimationFrame(gameLoop); }
    }

    requestAnimationFrame(gameLoop);
</script>
</body>
</html>